---
authors: Isaiah Becker-Mayer (isaiah@goteleport.com)
state: draft
---

# Desktop Access File System Sharing

## Introduction

At a high level, implementing drive (folder) redirection for Teleport is a matter of taking RDP's File System Virtual Channel Extension protocol (described in [[MS-RDPEFS]](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/34d9de58-b2b5-40b6-b970-f82d4603bdb5)), and converting it to the TDP protocol (described in this document).

```
                         Teleport Desktop Protocol                         RDP
                ------------------------------------------        ---------------------
                |                                        |        |                   |
+----------------------+     +------------------+  +------------------+     +------------------+
|                      |     |                  |  |                  |     |                  |
|                      |     |                  |  |    Teleport      |     |                  |
|  User's Web Browser  ------|  Teleport Proxy -----  Windows Desktop ------|  Windows Desktop |
|                      |     |                  |  |     Service      |     |                  |
+----------------------+     +------------------+  +------------------+     +------------------+
```

RDP is an old protocol, and is designed in some ways to be deeply compatible with Windows operating system, which means that it contains a lot of details that aren't necessarily relevant or available to our client, which is limited to sort of file information is available to us through the browser. While this reality creates its own set of implementation difficulties for us, it also creates an opportunity for us to simplify drive redirection in the TDP protocol.

Being such a longstanding, large, and complex protocol, it can sometimes be difficult to tell from it's documentation precisely how RDP is actually supposed to work. Adding to that difficulty is the File System Virtual Channel Extension designer's decision to leave some aspects of client and server dynamics unspecified:

"This protocol forwards server requests from the server-based application and returns replies from the client-file system. There are no specific rules implied by this protocol as to how and when a particular message is sent from the server and what the client is to reply." ([[MS-RDPEFS] 3.1.5.1](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/1a8715b1-3afc-4bd7-8ec2-9625a9ce9610))

In cases of protocol ambiguity, the open source project [FreeRDP](https://github.com/FreeRDP/FreeRDP) is an invaluable resource as a canonical implementation, which will be used for reference. This document attempts to be exhaustive for core drive sharing functionality; for any cases that aren't accounted for in this document, it should be assumed that we follow FreeRDP's conventions.

## RDP Background

### `Device I/O Request`s

After the initial drive negotiation, RDP directs the remote machine's use of the drive by sending [`Device I/O Request`s](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d). These requests are only sent from the server (the Windows Desktop) to the client (the Rust client running on Teleport's Windows Desktop Service).

#### `DeviceId`

In our case, `DeviceId` will always be whatever number we sent to the server in the [`Client Device List Announce`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/d8b2bc1c-0207-4c15-abe3-62eaa2afcaf1) message we sent to initialize drive redirection. For now we are only supporting sharing a single directory, so this field is more or less irrelevant to us for this initial implementation.

Since it's trivial to add, we will include a corresponding field `directory_id` in TDP that corresponds with this field.

#### `FileId`

A `FileId` is generated by the client upon reciept of a `Device I/O Request` where `MajorFunction = IRP_MJ_CREATE` and sent back to the server, which then uses it to denote that file in subsequent `Device I/O Request`s. The `FileId` is valid until the client receives a `Device I/O Request` with `MajorFunction = IRP_MJ_CLOSE`, at which point it becomes invalid and can be recycled.

The semantics of these `MajorFunction`s and how this system works isn't obvious at first glance, and will be clarified in the [Typical Operation](#typical-operation) section below.

#### `CompletionId`

`CompletionId`s are generated by the server and sent with each `Device I/O Request`. All `Device I/O Request`'s demand a [`Device I/O Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/1c412a84-0776-4984-b35c-3f0445fcae65) in response, and the server matches `Device I/O Response`s to `Device I/O Request`s by the `CompletionId` field.

This design allows operations to take place asynchronously/concurrently, and we will mimic in our TDP translation.

#### `MajorFunction` & `MinorFunction`

`Device I/O Request`s are classified by their `MajorFunction` field, which can contain the following values/semantics:

| Value                           | Meaning                          |
| ------------------------------- | -------------------------------- |
| IRP_MJ_CREATE                   | Create request                   |
| IRP_MJ_CLOSE                    | Close request                    |
| IRP_MJ_READ                     | Read request                     |
| IRP_MJ_WRITE                    | Write request                    |
| IRP_MJ_DEVICE_CONTROL           | Device control request           |
| IRP_MJ_QUERY_VOLUME_INFORMATION | Query volume information request |
| IRP_MJ_SET_VOLUME_INFORMATION   | Set volume information request   |
| IRP_MJ_QUERY_INFORMATION        | Query information request        |
| IRP_MJ_SET_INFORMATION          | Set information request          |
| IRP_MJ_DIRECTORY_CONTROL        | Directory control request        |
| IRP_MJ_LOCK_CONTROL             | File lock control request        |

`Device I/O Request`s are always the headers of more detailed request messages. For example, a `Device I/O Request` with its `MajorFunction` set to `IRP_MJ_CREATE` denotes the beginning of a [Device Create Request](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/5f71f6d2-d9ff-40c2-bdb5-a739447d3c3e), which contains further fields that specify the details of the request.

The `MinorFunction` further specifies `IRP_MJ_DIRECTORY_CONTROL` requests.

#### Typical Operation

As mentioned previously, the semantics of the `MajorFunction`s isn't necessarily obvious at first glance. For example, one might assume that an `IRP_MJ_CREATE` means "create a new file or directory", however it turns out this is only the case given a specific `CreateDisposition` in the attendant Device Create Request.

In fact, `IRP_MJ_CREATE` is sent at the beginning of any operation the server wants to execute. It most commonly just tells the client "create a reference to a file/directory and give it a `FileId`". The client does so and sends that `FileId` back to the server in response, and that `FileId` is then used in subsequent `Device I/O Request`s that act on that file/directory, such as reading or writing. Once the operation is complete, the server sends a `IRP_MJ_CLOSE`, which typically means "remove the reference you created previously".

As an example, here is what happens when the client first announces a new folder (named "abcdefg") to redirect (this first set of messages are not `Device I/O Request`s, they're just here to make the example realistic):

```
client (c) --> server (s): ClientDeviceListAnnounceRequest { device_count: 1, device_list: [DeviceAnnounceHeader { device_type: RDPDR_DTYP_FILESYSTEM, device_id: 2, preferred_dos_name: "abcdefg", device_data_length: 8, device_data: [97, 98, 99, 100, 101, 102, 103, 0] }] }

s --> c: ServerDeviceAnnounceResponse { device_id: 2, result_code: 0 }

c: ServerDeviceAnnounceResponse was valid!
```

The initial negotiation is complete, and the server now wants to query information about this new folder. First it sends an `IRP_MJ_CREATE`:

```
s --> c: DeviceCreateRequest { device_io_request: DeviceIoRequest { device_id: 2, file_id: 0, completion_id: 0, major_function: IRP_MJ_CREATE, minor_function: IRP_MN_NONE }, desired_access: FILE_READ_ATTRIBUTES, allocation_size: 0, file_attributes: (empty), shared_access: FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, create_disposition: FILE_OPEN, create_options: FILE_DIRECTORY_FILE, path_length: 0, path: "" }
```

We know it's referring to the top level directory we just shared in the `ClientDeviceListAnnounceRequest` by the corresponding `DeviceId` (`2`). The `Path` is an empty string (`""`), hence its requesting we create a reference for the top level directory itself. While `FileId` appears to be set to `0` in this request, this is actually just a junk field that should be ignored. The server is requesting that we create a `FileId` for the top level directory, which we will make `999` and respond with

```
c --> s: DeviceCreateResponse { device_io_reply: DeviceIoResponse { device_id: 2, completion_id: 0, io_status: 0 }, file_id: 999, information: FILE_SUPERSEDED }
```

The server knows that was in response to that specific `IRP_MJ_CREATE` because of it's corresponding `CompletionId` field. Internally on the client, we've created some data structure that remembers that `FileId` `999` means `(DeviceId: 2, Path: "")` (the top level of the shared directory).

```
s --> c: ServerDriveQueryInformationRequest { device_io_request: DeviceIoRequest { device_id: 2, file_id: 999, completion_id: 0, major_function: IRP_MJ_QUERY_INFORMATION, minor_function: IRP_MN_NONE }, fs_information_class_lvl: FileBasicInformation }
```

The server is asking us for information `IRP_MJ_QUERY_INFORMATION` about the tld (`FileId: 999`), which it wants back in the form of the [`FileBasicInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/16023025-8a78-492f-8b96-c873b042ac50) structure. (Here is where we would send a TDP message to gather that information from the client):

```
c --> s: ClientDriveQueryInformationResponse { device_io_response: DeviceIoResponse { device_id: 2, completion_id: 0, io_status: 0 }, length: 36, buffer: FileBasicInformation(FileBasicInformation { creation_time: 128271382742968750, last_access_time: 128271382742968750, last_write_time: 128271382742968750, change_time: 128271382742968750, file_attributes: FILE_ATTRIBUTE_DIRECTORY }) }
```

The server now has all the information it needs about this top level directory, and so it ends this action sequence with an `IRP_MJ_CLOSE`:

```
s --> c: DeviceCloseRequest { device_io_request: DeviceIoRequest { device_id: 2, file_id: 999, completion_id: 0, major_function: IRP_MJ_CLOSE, minor_function: IRP_MN_NONE } }
```

There is a case where this `IRP_MJ_CLOSE` would mean "delete the file/directory" (discussed below), but in this specific case it just means "this set of operations is over, remove the `FileId` reference on the client".

```
c --> s: DeviceCloseResponse { device_io_response: DeviceIoResponse { device_id: 2, completion_id: 0, io_status: 0 }, padding: 0 }
```

A similar process would then take place for other operations, for example a read of a file in the shared directory named `example.txt` would look like

1. server sends `IRP_MJ_CREATE` with `Path: "example.txt"`
2. client responds with a `FileId`
3. server sends `IRP_MJ_READ` for `FileId` for bytes 0 - 1024
4. client executes the read and responds with the data
5. server sends `IRP_MJ_CLOSE`

## RDP --> TDP Translation

The following section walks through each possible `Device I/O Request` (`MajorFunction`) and describe the TDP <--> RDP interface that we will use to handle them. As mentioned in the introduction, we will be considering FreeRDP as the canonical implementation, whose entrypoint for handling `Device I/O Request`s can be found [here](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L691-L749).

#### `IRP_MJ_CREATE`

Comes in the form of a [Device Create Request](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/5f71f6d2-d9ff-40c2-bdb5-a739447d3c3e). Our client will take the `DeviceId`, `CompletionId`, and `Path` and package them into their corresponding fields in the `File Info Request`.

## TDP File Shared Directory Extension

Extends the TDP protocol, the rest of which is specified [here](https://github.com/gravitational/teleport/blob/master/rfd/0037-desktop-access-protocol.md). Note that "file" in the following context should be taken to mean "file or directory".

#### 11 - Shared Directory Announce

| message type (11) | completion_id uint32 | directory_id uint32 |

This message announces a new directory to be shared over TDP. `directory_id` must be a unique identifier. Attempting to share multiple different directories using the same `directory_id` is undefined behavior.

#### 12 - Shared Directory Acknowledge

| message type (12) | completion_id uint32 |

Acknowledges a `Shared Directory Announce` was successfully received.

#### 13 - Shared Directory Error

| message type (13) | completion_id uint32 | error_code uint32 |

`error_code`s:

0. unspecified error

For now, all errors will be unspecified, and translated into [`NTSTATUS::STATUS_UNSUCCESSFUL`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55) over RDP. Later, we can add more specific error messages for more specific RDP error handling, [as they do in FreeRDP](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L67-L132).

#### 14 - File Info Request

```
| message type (14) | directory_id uint32 | completion_id uint32 | length uint32 | path []byte
```

This message is sent from the server to the client to request information about a file. The server will be expecting a `File Info Response` in response.

`completion_id` is generated by the server and must be returned by the client in its corresponding `File Info Response` or in an error response.

`directory_id` is the `directory_id` of the top level directory being shared, as specified in a previous `Announce Shared Directory` message.

`length` is the length in bytes of the `path`

`path` is the unix-style relative path to the file or directory, excepting special path characters ".", "..". Absolute paths, or those containing path elements with either of the special characters, will result in an error.

#### 15 - File Info Response
