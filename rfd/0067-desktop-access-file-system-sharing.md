---
authors: Isaiah Becker-Mayer (isaiah@goteleport.com)
state: draft
---

# Desktop Access File System Sharing

## Introduction

At a high level, implementing drive (folder) redirection for Teleport is a matter of taking RDP's File System Virtual Channel Extension protocol (described in
[[MS-RDPEFS]](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/34d9de58-b2b5-40b6-b970-f82d4603bdb5)), and converting it to the TDP protocol
(described in this document).

```
                         Teleport Desktop Protocol                         RDP
                ------------------------------------------        ---------------------
                |                                        |        |                   |
+----------------------+     +------------------+  +------------------+     +------------------+
|                      |     |                  |  |                  |     |                  |
|                      |     |                  |  |    Teleport      |     |                  |
|  User's Web Browser  ------|  Teleport Proxy -----  Windows Desktop ------|  Windows Desktop |
|                      |     |                  |  |     Service      |     |                  |
+----------------------+     +------------------+  +------------------+     +------------------+
```

RDP is an old protocol, and is designed in some ways to be deeply compatible with Windows operating system, which means that it contains a lot of details that
aren't necessarily relevant or available to our client, which is limited to sort of file information is available to us through the browser. While this reality
creates its own set of implementation difficulties for us, it also creates an opportunity for us to simplify drive redirection in the TDP protocol.

Being such a longstanding, large, and complex protocol, it can sometimes be difficult to tell from it's documentation precisely how RDP is actually supposed to
work. Adding to that difficulty is the File System Virtual Channel Extension designer's decision to leave some aspects of client and server dynamics unspecified:

"This protocol forwards server requests from the server-based application and returns replies from the client-file system. There are no specific rules implied by
this protocol as to how and when a particular message is sent from the server and what the client is to reply."
([[MS-RDPEFS] 3.1.5.1](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/1a8715b1-3afc-4bd7-8ec2-9625a9ce9610))

In cases of protocol ambiguity, the open source project [FreeRDP](https://github.com/FreeRDP/FreeRDP) is an invaluable resource as a canonical implementation,
which will be used for reference. This document attempts to be exhaustive for core drive sharing functionality; for any cases that aren't accounted for in this
document, it should be assumed that we follow FreeRDP's conventions and algorithms.

## RDP Background

### [`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)s

After the initial drive negotiation, RDP directs the remote machine's use of the drive by sending
[[`Device I/O Request`s](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d). These requests are only sent
from the server (the Windows Desktop) to the client (the Rust client running on Teleport's Windows Desktop Service).

#### `DeviceId`

In our case, `DeviceId` will always be whatever number we sent to the server in the
[`Client Device List Announce`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/d8b2bc1c-0207-4c15-abe3-62eaa2afcaf1) message we sent to
initialize drive redirection. For now we are only supporting sharing a single directory, so this field is more or less irrelevant to us for this initial
implementation.

Since it's trivial to add, we will include a corresponding field `directory_id` in TDP that corresponds with this field.

#### `FileId`

A `FileId` is generated by the client upon reciept of a [`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)
where `MajorFunction = IRP_MJ_CREATE` and sent back to the server, which then uses it to denote that file in subsequent
[`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)s. The `FileId` is valid until
the client receives a [`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d) with
`MajorFunction = IRP_MJ_CLOSE`, at which point it becomes invalid and can be recycled.

The semantics of these `MajorFunction`s and how this system works isn't obvious at first glance, and will be clarified in the
[Typical Operation](#typical-operation) section below. TDP won't make use of `FileId`, electing to use a file or directory's (unix-like) relative path in each
request. The relative `path` combined with `directory_id` gives a unique "id" to any shared file-like object for any number of root-level shared directories.

#### `CompletionId`

`CompletionId`s are generated by the server and sent with each [`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d).
All [`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)s demand a
[`Device I/O Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/1c412a84-0776-4984-b35c-3f0445fcae65) in response, and the server
matches [`Device I/O Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/1c412a84-0776-4984-b35c-3f0445fcae65)s to
[`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)s by the `CompletionId` field.

This design allows operations to take place asynchronously/concurrently, and we will mimic it in our TDP translation.

#### `MajorFunction` & `MinorFunction`

[`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)s are classified by their
`MajorFunction` field, which can contain the following values/semantics:

| Value                           | Meaning                          |
| ------------------------------- | -------------------------------- |
| IRP_MJ_CREATE                   | Create request                   |
| IRP_MJ_CLOSE                    | Close request                    |
| IRP_MJ_READ                     | Read request                     |
| IRP_MJ_WRITE                    | Write request                    |
| IRP_MJ_DEVICE_CONTROL           | Device control request           |
| IRP_MJ_QUERY_VOLUME_INFORMATION | Query volume information request |
| IRP_MJ_SET_VOLUME_INFORMATION   | Set volume information request   |
| IRP_MJ_QUERY_INFORMATION        | Query information request        |
| IRP_MJ_SET_INFORMATION          | Set information request          |
| IRP_MJ_DIRECTORY_CONTROL        | Directory control request        |
| IRP_MJ_LOCK_CONTROL             | File lock control request        |

[`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)s are always the headers of more
detailed request messages. For example, a [`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)
with its `MajorFunction` set to `IRP_MJ_CREATE` denotes the beginning of a [`Device Create Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/5f71f6d2-d9ff-40c2-bdb5-a739447d3c3e),
which contains further fields that specify the details of the request.

The `MinorFunction` further specifies `IRP_MJ_DIRECTORY_CONTROL` requests.

#### Typical Operation

As mentioned previously, the semantics of the `MajorFunction`s isn't necessarily obvious at first glance. For example, one might assume that an `IRP_MJ_CREATE`
means "create a new file or directory", however it turns out this is only the case given a specific `CreateDisposition` in the attendant
[`Device Create Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/5f71f6d2-d9ff-40c2-bdb5-a739447d3c3e).

In fact, `IRP_MJ_CREATE` is sent at the beginning of any operation the server wants to execute. It most commonly just tells the client "create a reference to a
file/directory and give it a `FileId`". The client does so and sends that `FileId` back to the server in response, and that `FileId` is then used in subsequent
[`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)s that act on that file/
directory, such as reading or writing. Once the operation is complete, the server sends a `IRP_MJ_CLOSE`, which typically means "remove the reference you created
previously".

As an example, here is what happens when the client first announces a new folder (named "abcdefg") to redirect (this first set of messages are not
[`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)s, they're just here to make the
example realistic):

```
client (c) --> server (s): ClientDeviceListAnnounceRequest { device_count: 1, device_list: [DeviceAnnounceHeader { device_type: RDPDR_DTYP_FILESYSTEM, device_id: 2, preferred_dos_name: "abcdefg", device_data_length: 8, device_data: [97, 98, 99, 100, 101, 102, 103, 0] }] }

s --> c: ServerDeviceAnnounceResponse { device_id: 2, result_code: 0 }

c: ServerDeviceAnnounceResponse was valid!
```

The initial negotiation is complete, and the server now wants to query information about this new folder. First it sends an `IRP_MJ_CREATE`:

```
s --> c: DeviceCreateRequest { device_io_request: DeviceIoRequest { device_id: 2, file_id: 0, completion_id: 0, major_function: IRP_MJ_CREATE, minor_function: IRP_MN_NONE }, desired_access: FILE_READ_ATTRIBUTES, allocation_size: 0, file_attributes: (empty), shared_access: FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, create_disposition: FILE_OPEN, create_options: FILE_DIRECTORY_FILE, path_length: 0, path: "" }
```

We know it's referring to the top level directory we just shared in the `ClientDeviceListAnnounceRequest` by the corresponding `DeviceId` (`2`). The `Path` is an
empty string (`""`), hence its requesting we create a reference for the top level directory itself. While `FileId` appears to be set to `0` in this request, this
is actually just a junk field that should be ignored. The server is requesting that we create a `FileId` for the top level directory, which we will make `999` and
respond with

```
c --> s: DeviceCreateResponse { device_io_reply: DeviceIoResponse { device_id: 2, completion_id: 0, io_status: 0 }, file_id: 999, information: FILE_SUPERSEDED }
```

The server knows that was in response to that specific `IRP_MJ_CREATE` because of it's corresponding `CompletionId` field. Internally on the client, we've created
some data structure that remembers that `FileId` `999` means `(DeviceId: 2, Path: "")` (the top level of the shared directory).

```
s --> c: ServerDriveQueryInformationRequest { device_io_request: DeviceIoRequest { device_id: 2, file_id: 999, completion_id: 0, major_function: IRP_MJ_QUERY_INFORMATION, minor_function: IRP_MN_NONE }, fs_information_class_lvl: FileBasicInformation }
```

The server is asking us for information `IRP_MJ_QUERY_INFORMATION` about the tld (`FileId: 999`), which it wants back in the form of the
[`FileBasicInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/16023025-8a78-492f-8b96-c873b042ac50) structure. (Here is where we
would send a TDP message to gather that information from the client):

```
c --> s: ClientDriveQueryInformationResponse { device_io_response: DeviceIoResponse { device_id: 2, completion_id: 0, io_status: 0 }, length: 36, buffer: FileBasicInformation(FileBasicInformation { creation_time: 128271382742968750, last_access_time: 128271382742968750, last_write_time: 128271382742968750, change_time: 128271382742968750, file_attributes: FILE_ATTRIBUTE_DIRECTORY }) }
```

The server now has all the information it needs about this top level directory, and so it ends this action sequence with an `IRP_MJ_CLOSE`:

```
s --> c: DeviceCloseRequest { device_io_request: DeviceIoRequest { device_id: 2, file_id: 999, completion_id: 0, major_function: IRP_MJ_CLOSE, minor_function: IRP_MN_NONE } }
```

There is a case where this `IRP_MJ_CLOSE` would mean "delete the file/directory" (discussed below), but in this specific case it just means "this set of operations
is over, remove the `FileId` reference on the client".

```
c --> s: DeviceCloseResponse { device_io_response: DeviceIoResponse { device_id: 2, completion_id: 0, io_status: 0 }, padding: 0 }
```

A similar process would then take place for other operations, for example a read of a file in the shared directory named `example.txt` would look like

1. server sends `IRP_MJ_CREATE` with `Path: "example.txt"`
2. client responds with a `FileId`
3. server sends `IRP_MJ_READ` for `FileId` for bytes 0 - 1024
4. client executes the read and responds with the data
5. server sends `IRP_MJ_CLOSE`

## RDP --> TDP Translation

The following section walks through each possible [`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)
(`MajorFunction`) and describe the TDP <--> RDP interface that we will use to handle them. As mentioned in the introduction, we will be considering FreeRDP as the
canonical implementation, whose entrypoint for handling [`Device I/O Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/a087ffa8-d0d5-4874-ac7b-0494f63e2d5d)s
can be found [here](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L691-L749).

#### `IRP_MJ_CREATE`

RDP request: [`Device Create Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/5f71f6d2-d9ff-40c2-bdb5-a739447d3c3e)

RDP response: [`Device Create Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/99e5fca5-b37a-41e4-bc69-8d7da7860f76)

FreeRDP: [entry point](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L151)

Note that the `SharedAccess` and `DesiredAccess` fields of the [`Device Create Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/5f71f6d2-d9ff-40c2-bdb5-a739447d3c3e)
will be ignored. `SharedAccess` is related to file locking, which typically only has an "advisory" (as opposed to "mandatory") implementation on Unix-based OS's
and we will assume is unimportant ([more here](https://www.thegeekstuff.com/2012/04/linux-file-locking-types/)). In FreeRDP `DesiredAccess` essentially sets
[whether or not the file is writeable](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/winpr/libwinpr/file/file.c#L702). Because
file handles in the browser are always writeable, we will simply ignore this field.

Our client will start by taking the `DeviceId`, `CompletionId`, and `Path` fields from the [`Device Create Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/5f71f6d2-d9ff-40c2-bdb5-a739447d3c3e)
and sending them on to the client in their corresponding fields in the `Shared Directory Info Request`. The algorithm will work as does the meat of the FreeRDP
algorithm (found [here](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_file.c#L207-L332)). where
`GetFileAttributesW` is substituted with `Shared Directory Info Request`, and `CreateDirectoryW` and `CreateFileW` are substituted with a `Shared Directory Create Request`
(roughly speaking. Note that our `Shared Directory Create Request` fails if the file/directory already exists whereas `CreateDirectoryW` and `CreateFileW` don't
necessarily, and so our algorithm should account for this).

##### `file_id_cache`

Upon the successful execution of the algorithmic translation, our client will also create an entry in an internal `file_id_cache` indexed by `FileId`, with an
object that looks like:

```json
{
  "path": "relative/path/to/file/or/dir",
  "delete_pending": false,
  "fsos": [], // list of File System Objects, see below
  "fsos_index": 0
}
```

This is our version of the `IRP_MJ_CREATE` semantics of "create a reference to a file/directory and give it a `FileId`" discussed above, and will be used in
responding to other `MajorFunctions` as needed. All other `MajorFunctions` should begin by checking that an entry at `FileId` exists in this cache, and return an
[`Device Close Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/0dae7031-cfd8-4f14-908c-ec06e14997b5) with `IoStatus` set to
`STATUS_UNSUCCESSFUL` if it does not.

#### `IRP_MJ_CLOSE`

RDP request: [`Device Close Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/3ec6627f-9e0f-4941-a828-3fc6ed63d9e7)

RDP response: [`Device Close Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/0dae7031-cfd8-4f14-908c-ec06e14997b5)

FreeRDP: [entry point](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L236)

If file's `file_id_cache` entry has `delete_pending == true`, we'll send a `Shared Directory Delete Request` to the client and it's resultant `Shared Directory Delete Response`
or `Shared Directory Error` will be translated into an appropriate [`Device Close Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/0dae7031-cfd8-4f14-908c-ec06e14997b5).
The `file_id_cache` entry then must be deleted (even if the `Shared Directory Delete Request` fails).

#### `IRP_MJ_READ`

RDP request: [`Device Read Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/3192516d-36a6-47c5-987a-55c214aa0441)

RDP response: [`Device Read Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/d35d3f91-fc5b-492b-80be-47f483ad1dc9)

FreeRDP: [entry point](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L268)

The `Length` and `Offset` fields should be passed on to their corresponding fields in a `Shared Directory Read Request` and sent to the client, and corresponding
fields in the `Shared Directory Read Response` or `Shared Directory Error` the client sends back should be packaged into a
[`Device Read Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/d35d3f91-fc5b-492b-80be-47f483ad1dc9) and retuned to the RDP server.

#### `IRP_MJ_WRITE`

RDP request: [`Device Write Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/2e25f0aa-a4ce-4ff3-ad62-ab6098280a3a)

RDP response: [`Device Write Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/58160a47-2379-4c4a-a99d-24a1a666c02a)

FreeRDP: [entry point](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L326)

The `Offset`, `Length`, and `WriteData` fields should be translated to their corresponding fields in a `Shared Directory Write Request` and passed to the client,
and the corresponding fields in the `Shared Directory Write Response` or `Shared Directory Error` should be translated into an
[`Device Write Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/58160a47-2379-4c4a-a99d-24a1a666c02a) and sent back to the RDP
server.

#### `IRP_MJ_QUERY_INFORMATION`

RDP request: [`Server Drive Query Information Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/e43dcd68-2980-40a9-9238-344b6cf94946)

RDP response: [`Client Drive Query Information Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/37ef4fb1-6a95-4200-9fbf-515464f034a4)

FreeRDP: [entry point](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L373)

This request asks for information about a file or directory in the form of [`FileBasicInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/16023025-8a78-492f-8b96-c873b042ac50),
[`FileStandardInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/5afa7f66-619c-48f3-955f-68c4ece704ae), or
[`FileAttributeTagInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/d295752f-ce89-4b98-8553-266d37c84f0e), which collectively ask
for the following fields, mapped to the `Shared Directory Info Response` fields we will fill them out with the following mapping to `File System Object` fields:

- `CreationTime` --> `last_modified`
- `LastAccessTime` --> `last_modified`
- `LastWriteTime` --> `last_modified`
- `ChangeTime` --> `last_modified`
- [`FileAttributes`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/ca28ec38-f155-4768-81d6-4bfeb8586fc9) --> `file_type = file` maps to `FILE_ATTRIBUTE_NORMAL`, `file_type = directory` maps to `FILE_ATTRIBUTE_DIRECTORY`
- `AllocationSize` --> `size`
- `EndOfFile` --> `size`
- `NumberOfLinks` --> 0
- `DeletePending` --> `file_id_cache[FileId].delete_pending`
- and `Directory` --> `TRUE` if `file_type = directory` else `FALSE`

#### `IRP_MJ_SET_INFORMATION`

RDP Request: [`Server Drive Set Information Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/b5d3104b-0e42-4cf8-9059-e9fe86615e5c)

RDP Response: [`Client Drive Set Information Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/16b893d5-5d8b-49d1-8dcb-ee21e7612970)

FreeRDP: [entry point](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L404)

This message is sent by the RDP server to the client in order to modify a file's metadata, truncate its size, or mark it for deletion. Which of these operations
its intended for is determined by the `FsInformationClass` field, which will determine our response (also see
[FreeRDP' implementation](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_file.c#L579) for reference):

[`FileBasicInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/16023025-8a78-492f-8b96-c873b042ac50): This type of request is for
setting file metadata like creation time, last access time, etc. We don't have this level of access to file attributes in the browser. Fortunately, this degree of
control isn't critical for the basic application of sharing a directory of standard files, so we will just ignore these types of requests and send back a
[`Client Drive Set Information Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/16b893d5-5d8b-49d1-8dcb-ee21e7612970) with
`IoStatus = STATUS_SUCCESS`.

[`FileEndOfFileInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/75241cca-3167-472f-8058-a52d77c6bb17) or
[`FileAllocationInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/0201c69b-50db-412d-bab3-dd97aeede13b): This is a "truncate"
request. It's not quite clear how this might be implemented on the client. I've determined empirically that we can just send back a
[`Client Drive Set Information Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/16b893d5-5d8b-49d1-8dcb-ee21e7612970) with
`IoStatus = STATUS_SUCCESS` here without doing anything, and nothing breaks for editing basic text files, so we will start with that and reassess if we run into
problems.

[`FileDispositionInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/12c3dd1c-14f6-4229-9d29-75fb2cb392f6): This type of message can
mark a file or directory for deletion, which we will do by marking the corresponding entry in `file_id_cache` with `delete_pending: true`. The actual deletion is
not carried out here (see `IRP_MJ_CLOSE`).

[`FileRenameInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/1d2673a8-8fb9-4868-920a-775ccaa30cf8): Sent to rename a file. If
`ReplaceIfExists == FALSE`, start the operation with a `Shared Directory Info Request` for the `FileName` and only continue if we receive a "resource does not
exist" `Shared Directory Error`. Send a `Shared Directory Move Request`, using `file_id_cache.path` for `original_path` and `FileName` for `new_path`.

#### `IRP_MJ_DIRECTORY_CONTROL`

RDP Request: [`Server Drive Query Directory Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/458019d2-5d5a-4fd4-92ef-8c05f8d7acb1)

RDP Response: [`Client Drive Query Directory Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/9c929407-a833-4893-8f20-90c984756140)

FreeRDP: [entry point](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L650)

The above RDP request and response correspond to `MajorFunction = IRP_MJ_DIRECTORY_CONTROL`, `MinorFunction = IRP_MN_QUERY_DIRECTORY`. There is another possible
`MinorFunction` called `IRP_MN_NOTIFY_CHANGE_DIRECTORY`,
[but like FreeRDP we will ignore it](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L660).

The way these requests work is somewhat odd -- first, a directory will be "opened" with an `IRP_MJ_OPEN` (per usual), then it will receive a series of
`IRP_MJ_DIRECTORY_CONTROL` requests, each asking for an individual item in the identified directory, before being closed with an `IRP_MJ_CLOSE` (also per usual).
The first of the series of requests will have `InitialQuery` set to `TRUE`, while subsequent requests will have it set to `FALSE`. Unlike most RDP messages,
[`Client Drive Query Directory Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/9c929407-a833-4893-8f20-90c984756140)s do allow
for [dot directory names](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/fccd0313-0364-45bd-b75c-924fd6a5662f), and when running FreeRDP on
MacOS the first two
[`Client Drive Query Directory Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/9c929407-a833-4893-8f20-90c984756140)s are always
for `"."` and `".."`.

Upon receipt of an [`Server Drive Query Directory Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/458019d2-5d5a-4fd4-92ef-8c05f8d7acb1)
with `InitialQuery` set to `TRUE`, we will extract the `path` from the `file_id_cache` and execute a `Shared Directory List Request`, whose `Shared Directory List Response`
will be stored in `file_id_cache.fsos`. (If the client instead responds with a "resource does not exist" `Shared Directory Error`, we must send back a `Client I/O Response`
with `IoStatus` set to `STATUS_NO_SUCH_FILE`). The client can then respond with a [`Client Drive Query Directory Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/9c929407-a833-4893-8f20-90c984756140) for `"."`.

We will now expect a subsequent
[`Server Drive Query Directory Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/458019d2-5d5a-4fd4-92ef-8c05f8d7acb1) with
`InitialQuery` now set to `FALSE`, to which we'll respond back with a
[`Client Drive Query Directory Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/9c929407-a833-4893-8f20-90c984756140) for `".."`
with a set of default values (listed below). On subsequent requests, we will take `file_id_cache.fsos[file_id_cache.fsos_index]` and send it back in a
[`Client Drive Query Directory Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/9c929407-a833-4893-8f20-90c984756140),
incrementing `file_id_cache.fsos_index` each time. Finally, we'll recieve a
[`Server Drive Query Directory Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/458019d2-5d5a-4fd4-92ef-8c05f8d7acb1) for which we
have no additional item to report back, at which point we will send back a `Client I/O Response` with `IoStatus` set to `STATUS_NO_SUCH_FILE`, thus ending the
sequence (at which point the server will send us an `IRP_MJ_CLOSE` for this `FileId`).

[`Server Drive Query Directory Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/458019d2-5d5a-4fd4-92ef-8c05f8d7acb1) can ask for
information back in any of the following formats:
[`FileDirectoryInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/b38bf518-9057-4c88-9ddd-5e2d3976a64b),
[`FileFullDirectoryInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/e8d926d1-3a22-4654-be9c-58317a85540b),
[`FileBothDirectoryInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/270df317-9ba5-4ccb-ba00-8d22be139bc5), or
[`FileNamesInformation`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/a289f7a8-83d2-4927-8c88-b2d328dde5a5) (handled by FreeRDP starting
[here](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_file.c#L796)). Collectively these data
structures will be filled out with the following mapping to `File System Object` fields. In case such fields don't exist (such as for the `".."` directory), I've
included a default mapping value as well:

- `CreationTime` --> `last_modified`, 0 (default)
- `LastAccessTime` --> `last_modified`, 0
- `LastWriteTime` --> `last_modified`, 0
- `ChangeTime` --> `last_modified`, 0
- [`FileAttributes`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/ca28ec38-f155-4768-81d6-4bfeb8586fc9) --> `file_type = file` maps to `FILE_ATTRIBUTE_NORMAL`, `file_type = directory` maps to `FILE_ATTRIBUTE_DIRECTORY`, default `FILE_ATTRIBUTE_DIRECTORY`
- `AllocationSize` --> `size`, 0
- `EndOfFile` --> `size`, 0
- `FileName` --> last path item in the `path`

#### `IRP_MJ_LOCK_CONTROL`

[FreeRDP silently ignores these messages](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_file.c#L579) and so will we.

#### `IRP_MJ_QUERY_VOLUME_INFORMATION`

RDP request: [`Server Drive Query Volume Information Request`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/484e622d-0e2b-423c-8461-7de38878effb)

RDP response: [`Client Drive Query Volume Information Response`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpefs/fbdc7db8-a268-4420-8b5e-ce689ad1d4ac)

FreeRDP: [entry point](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L442)

This request comes to us as a in search of low level information about the folder we are sharing. This information is not available to us via the browser, so there
is no corresponding TDP message in this case. We will simply follow what FreeRDP does
[here](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L442-L581). We will emulate
[`GetDiskFreeSpaceW`](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/winpr/libwinpr/file/file.c#L1025-L1041) by using
[`UINT32_MAX`] for each of `lpSectorsPerCluster`, `lpNumberOfFreeClusters`, and `lpTotalNumberOfClusters`, and `1` for `lpBytesPerSector` (taken from
[`GetDiskFreeSpaceA`](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/winpr/libwinpr/file/file.c#L1007-L1023)).

Hopefully this is good enough to keep everything running smoothly. We will need to experiment manually to check that this approach doesn't cause any obvious
problems, and reassess if it does.

#### `IRP_MJ_DEVICE_CONTROL`

This is effectively a no-op [in FreeRDP](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L677-L684).
We have an implementation of it in order to handle our smartcard simulation, but it's irrelevant to this document.

#### `IRP_MJ_SET_VOLUME_INFORMATION`

This is not supported by FreeRDP and causes it to execute
[the `default` case](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L742-L745) which we will
emulate.

## TDP File Shared Directory Extension

Extends the TDP protocol, the rest of which is specified [here](https://github.com/gravitational/teleport/blob/master/rfd/0037-desktop-access-protocol.md). Note
that "file" in the following context should be taken to mean "file or directory".

#### 11 - Shared Directory Announce

```
| message type (11) | directory_id uint32 | name_length uint32 | name []byte |
```

This message announces a new directory to be shared over TDP. `directory_id` must be a unique identifier. Attempting to share multiple different directories using
the same `directory_id` is undefined behavior.

`name_length` is the length in bytes of the `name`

`name` is the name of the directory (without any path prefix)

#### 12 - Shared Directory Acknowledge

```
| message type (12) | err error | directory_id uint32 |
```

Acknowledges a `Shared Directory Announce` was received.

`err` is a `Shared Directory Error`. `0` ("nil") means the `Shared Directory Announce` was successfully processed, `1` ("operation failed") means processing failed.

`directory_id` is the `directory_id` of the top level directory being shared, as specified in the `Announce Shared Directory` message this message is acknowledging.

#### 13 - Shared Directory Info Request

```
| message type (13) | completion_id uint32 | directory_id uint32 | path_length uint32 | path []byte |
```

This message is sent from the server to the client to request information about a file. The server will be expecting a `Shared Directory Info Response`.

`completion_id` is generated by the server and must be returned by the client in its corresponding `Shared Directory Info Response` or `Shared Directory Error`
response.

`directory_id` is the `directory_id` of the top level directory being shared, as specified in a previous `Announce Shared Directory` message.

`path_length` is the length in bytes of the `path`

`path` is the unix-style relative path (from the root-level directory specified by `directory_id`) to the file or directory, excepting special path characters ".",
"..". Absolute paths, or those containing path elements with either of the special characters, will result in an error. Info can be requested for the root-level
directory by setting `path_length: 0` and `path: ""`.

#### 14 - Shared Directory Info Response

```
| message type (14) | completion_id uint32 | err error | file_system_object fso |
```

This message is sent by the client to the server in response to a `Shared Directory Info Request`.

`completion_id` must match the `completion_id` of the `Shared Directory Info Request` that this message is responding to.

`err` is a `Shared Directory Error`. If a file or directory at `path` does not exist, this should be set to `2` ("resource does not exist").

`file_system_object` is the file system object.

#### 15 - Shared Directory Create Request

```
| message type (15) | completion_id uint32 | directory_id uint32 | file_type uint32 | path_length uint32 | path []byte |
```

This message is sent by the server to the client to request the creation of a new file or directory.

`completion_id` is generated by the server and must be returned by the client in its corresponding `Shared Directory Create Response` or `Shared Directory Error`
response.

`directory_id` is the `directory_id` of the top level directory being shared, as specified in a previous `Announce Shared Directory` message.

`file_type` matches the specification in `Shared Directory Info Response`.

`path_length` is the length in bytes of the `path`.

`path` is the unix-style relative path (from the root-level directory specified by `directory_id`) to the file or directory, excepting special path characters ".",
"..". Absolute paths, or those containing path elements with either of the special characters, will result in an error.

#### 16 - Shared Directory Create Response

```
| message type (16) | completion_id uint32 | err error |
```

This message is sent by the client to the server to acknowledge a `Shared Directory Create Request` was successfully executed. A `Shared Directory Create Request`
that fails should respond with an "operation failed" `Shared Directory Error`.

`completion_id` must match the `completion_id` of the `Shared Directory Create Request` that this message is responding to.

`err` is a `Shared Directory Error`. If a filesystem object at `path` already exists, this should be set to `3` ("resource already exists").

#### 17 - Shared Directory Delete Request

```
| message type (17) | completion_id uint32 | directory_id uint32 | path_length uint32 | path []byte |
```

This message is sent by the server to the client to request the deletion of a file or directory at `path`.

`completion_id` is generated by the server and must be returned by the client in its corresponding `Shared Directory Delete Response` or `Shared Directory Error`
response.

`directory_id` is the `directory_id` of the top level directory being shared, as specified in a previous `Announce Shared Directory` message.

`path_length` is the length in bytes of the `path`.

`path` is the unix-style relative path (from the root-level directory specified by `directory_id`) to the file or directory, excepting special path characters ".",
"..". Absolute paths, or those containing path elements with either of the special characters, will result in an error.

#### 18 - Shared Directory Delete Response

```
| message type (18) | completion_id uint32 | err error |
```

This message is sent by the client to the server to acknowledge a `Shared Directory Delete Request` was successfully executed. A `Shared Directory Create Request`
that fails should respond with an appropriate `Shared Directory Error`.

`completion_id` must match the `completion_id` of the `Shared Directory Delete Request` that this message is responding to.

`err` is a `Shared Directory Error`. If the delete fails, this should be set to `1` ("operation failed"). If the file or directory does not exist, this should be set to `2` ("resource does not exist").

#### 19 - Shared Directory Read Request

```
| message type (19) | completion_id uint32 | directory_id uint32 | path_length uint32 | path []byte | offset uint64 | length uint32 |
```

This message is sent by the server to the client to request a maximum of `length` bytes be read from the file at `path`, starting at byte offset `offset`.

`completion_id` is generated by the server and must be returned by the client in its corresponding `Shared Directory Read Response` or `Shared Directory Error`
response.

`directory_id` is the `directory_id` of the top level directory being shared, as specified in a previous `Announce Shared Directory` message.

`path_length` is the length in bytes of the `path`.

`path` is the unix-style relative path (from the root-level directory specified by `directory_id`) to the file or directory, excepting special path characters ".",
"..". Absolute paths, or those containing path elements with either of the special characters, will result in an error.

`offset` specifies the file offset where the read operation is performed.

`length` specifies the maximum number of bytes to be read from the device.

#### 20 - Shared Directory Read Response

```
| message type (20) | completion_id uint32 | err error | read_data_length uint32 | read_data []byte |
```

This message is sent by the client to the server in response to a `Shared Directory Read Request`.

`completion_id` must match the `completion_id` of the `Shared Directory Read Request` that this message is responding to.

`err` is a `Shared Directory Error`. If the file does not exist or the path is to a directory, this field should be set to `2` ("resource does not exist"). For any other error, this field should be set to `1` ("operation failed").

`read_data_length` specifies the number of bytes in the `read_data` field.

`read_data` are the raw bytes that were read.

#### 21 - Shared Directory Write Request

```
| message type (21) | completion_id uint32 | directory_id uint32 | path_length uint32 | path []byte | offset uint64 | write_data_length uint32 | write_data []byte |
```

This message is sent by the server to the client to request `write_data` be written to the file specified by `path`.

`completion_id` is generated by the server and must be returned by the client in its corresponding `Shared Directory Write Response` or `Shared Directory Error` response.

`directory_id` is the `directory_id` of the top level directory being shared, as specified in a previous `Announce Shared Directory` message.

`path_length` is the length in bytes of the `path`.

`path` is the unix-style relative path (from the root-level directory specified by `directory_id`) to the file or directory, excepting special path characters ".",
"..". Absolute paths, or those containing path elements with either of the special characters, will result in an error.

`offset` specifies the file offset where the write operation should start from.

`write_data_length` is the length of `write_data`

`write_data` is the raw data to be written.

#### 22 - Shared Directory Write Response

```
| message type (22) | completion_id uint32 | err error | bytes_written uint32 |
```

This message is sent by the client to the server in response to a `Shared Directory Write Request`.

`completion_id` must match the `completion_id` of the `Shared Directory Write Request` that this message is responding to.

`err` is a `Shared Directory Error`. If the file does not exist or the path is to a directory, this field should be set to `2` ("resource does not exist"). For any other error, this field should be set to `1` ("operation failed").

`bytes_written` specifies the number of bytes that were written.

#### 23 - Shared Directory Move Request

```
| message type (23) | completion_id uint32 | original_path_length uint32 | original_path []byte | new_path_length uint32 | new_path []byte |
```

This message is sent by the server to the client to request a file or directory be moved (or renamed). It should be expected to work like the
linux [`mv`](https://linux.die.net/man/1/mv) utility (with no flags).

`completion_id` is generated by the server and must be returned by the client in its corresponding `Shared Directory Move Response` or `Shared Directory Error`
response.

`original_path_length` is the length of `original_path`

`original_path` is the existing path of the file or directory being moved.

`new_path_length` is the length of `new_path`

`new_path` is the new path for the file or directory being moved.

#### 24 - Shared Directory Move Response

```
| message type (24) | completion_id uint32 | err error |
```

This message is sent by the client to the server in response to a `Shared Directory Move Request` to alert the server of a successful move operation.

`completion_id` must match the `completion_id` of the `Shared Directory Move Request` that this message is responding to.

`err` is a `Shared Directory Error`. If the `original_path` in the `Shared Directory Move Request` does not exist, this field should be set to `2` ("resource does not exist"). For any other error, this field should be set to `1` ("operation failed").

#### 25 - Shared Directory List Request

| message type (25) | completion_id uint32 | path_length uint32 | path []byte |

This message is sent by the server to the client to request the contents of a directory.

`completion_id` is generated by the server and must be returned by the client in its corresponding `Shared Directory List Response` or `Shared Directory Error` response.

`path_length` is the length in bytes of the `path`

`path` is the unix-style relative path (from the root-level directory specified by `directory_id`) to the file or directory, excepting special path characters ".",
"..". Absolute paths, or those containing path elements with either of the special characters, will result in an error. Info can be requested for the root-level
directory by setting `path_length: 0` and `path: ""`.

#### 26 - Shared Directory List Response

```
| message type (26) | completion_id uint32 | err error | fso_list_length uint32 | fso_list fso[] |
```

This message is sent by the client to the server in response to a `Shared Directory Info Request`.

`completion_id` must match the `completion_id` of the `Shared Directory List Request` that this message is responding to.

`err` is a `Shared Directory Error`. If the `original_path` in the `Shared Directory Move Request` does not exist or the path is to a file, this field should be set to `2` ("resource does not exist"). For any other error, this field should be set to `1` ("operation failed").

`fso_list_length` is the number of entries in the `fso_list`.

`fso_list` is a list of `fso` objects representing all the files and directories in the directory specified by the `path` variable in the originating
`Shared Directory List Request`.

##### File System Object (fso)

```
| last_modified uint32 | size uint64 | file_type uint32 | path_length uint32 | path byte[] |
```

`last_modified` is the last modified time of the file, in milliseconds since the [UNIX epoch](https://en.wikipedia.org/wiki/Unix_time).

`size` is the size of the file in bytes

`file_type`s currently represents only the simple file/directory distinction. Later it may be modified to support more types such as those corresponding to the
types available in RDP's [File Attributes](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/ca28ec38-f155-4768-81d6-4bfeb8586fc9) fields:

0. file
1. directory

The design of this message is constrained by [what information is made available to us by the browser](https://developer.mozilla.org/en-US/docs/Web/API/File) and
which [File Information Classes](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/4718fc40-e539-4014-8e33-b675af74e3e1) are potentially
requested by RDP.

`path_length` is the length in bytes of the `path`

`path` is the unix-style relative path (from the root-level directory specified by `directory_id`) to the file or directory, excluding special path characters ".",
"..". Absolute paths, or those containing path elements with either of the special characters, are considered an error. A root-level shared directory is specified
by setting `path_length: 0` and `path: ""`.

##### Shared Directory Error (error)

`error` is a `uint32` sized field specifying an error

0. nil (no error, operation succeeded)
1. operation failed
2. resource does not exist
3. resource already exists

For now, all errors will be unspecified, and translated into
[`NTSTATUS::STATUS_UNSUCCESSFUL`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55) over RDP. Later, we
can add more specific error messages for more specific RDP error handling,
[as they do in FreeRDP](https://github.com/FreeRDP/FreeRDP/blob/511444a65e7aa2f537c5e531fa68157a50c1bd4d/channels/drive/client/drive_main.c#L67-L132).
